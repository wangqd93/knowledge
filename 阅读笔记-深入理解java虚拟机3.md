## jvm

### 对象的创建过程

当java 虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有那么必须先执行相应的类加载的过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。

分配对象有两种方式

+ 指针碰撞：堆内存绝对工整，一侧空闲，一侧使用，可直接跳针临界指针，一般取决于是否带有空间压缩算法（serial、ParNew）
+ 空闲列表：维护一个列表，记录那些可以分配（cms）

new指令之后会接着执行<init>()方法，按照程序猿的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。



### 对象的组成

对象氛围三个部分：对象头 + 实例数据 + 对齐填充

#### 对象头

对象头包含两类信息：

第一类是用于存储对象自身的运行时数据，如hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等。

这部分数据的长度在32位和64位的虚拟机汇总分别占用32个比特和64个比特。

对象头的另外一部分是类型指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留指针。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据。

#### 实例数据

实例数据就是存储实力对象的有效信息

#### 对齐填充

对象的其实地址必须是8字节的整数倍，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。



### 垃圾收集

#### 如何判断对象已死

+ 引用计数法
+ 可达性分析（GC Roots）
  + 在虚拟机栈（栈帧中的本地变量表）中的引用对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量。
  + 在方法区中类静态属性引用的对象，比如java类中的引用类型静态变量
  + 在方法区中常量引用的对象，比如字符串常量池里的引用。
  + 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
  + java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NPE，OOM）等，还有系统类加载器
  + 所有被同步锁（synchronized关键字）持有的对象。
  + 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 引用类型

#### 强引用（strongly reference）

通过new关键字创建的，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象

#### 软引用（soft reference）

软引用是用来描述一些还有用，但非必需的对象。系统发生内存溢出前，会把这些对象列进回收范围之中进行二次回收，如果还没有足够的内存，才会抛出

#### 弱引用（weak reference）

弱引用也是用来描述那些非必需对象，但是它的强度比软引用更弱一些，被弱引用关联的对象智能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

#### 虚引用（phantom reference）

一个对象是否有虚引用的存在，完全不会对其生存时间构成印象，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能够在这个对象被回收时收到一个系统通知。



### 垃圾收集算法

#### 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。

cms 收集器

缺点：

+ 执行效率不稳定
+ 内存空间的碎片化

#### 标记-复制算法

将可用空间分为大小相等的两块，每次使用其中一块，当一块的内存用完，就将还存活着的对象复制到另外一块上面。

缺点：

+ 可用内存缩小为了原来的一半

#### 标记-整理算法

其中标记过程仍然与“标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都想内存空间一段移动。

parallel Scavenge 收集器

缺点

+ 会带来额外的延时

优点

+ 吞吐量上升

#### remembered set

为了解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立名为记忆集（remembered set）的数据结构，用以避免把整个老年代加进GC root扫描范围。



### 三色标级算法

当且仅当以下两个条件同事满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色对象：

+ 赋值器插入了一条或多条从黑色对象到白色对象的新引用
+ 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

#### 增量更新

当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等兵法扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。

#### 原始快照（SATB）

当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。

cms时基于增量更新来做并发标记的，G1，Shenandoah则是用原始快照来实现的

### 垃圾收集器

#### serial 收集器

最早的收集器，依然是hotspot虚拟机运行在客户端模式下新生代收集器，简单高效，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。

#### ParNew 收集器

serial 收集器的多线程并行版本。

除了Serial收集器外，目前只有它能与cms收集器配合工作。

并行：同一时间有多条线程协同工作

并发：同一时间垃圾收集器与用户线程都在运行。由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

#### Paralllel Scavenge 收集器

Paralllel Scavenge 是一款新生代收集器，基于标记-复制算法，目标是可控制的吞吐量。

#### Serial Old 收集器

serial Old 是Serial收集器的老年代版本，使用标记-整理算法。

一种是jdk5以及之前的版本中与Paralle Scavenge收集器搭配使用，一种是作为cms收集器失败时的后备预案。

#### Parallel Old 收集器

Parallel Old 是Paralle Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记整理算法。jdk6开始提供。

吞吐量优先可以选择Parallel Scavenge + Parallel Old

#### CMS 收集器

以获取最短回收停顿为目标的收集器。jdk5发布

cms包含四个步骤

+ 初始标记（STW）

  标记GC Roots 对象

+ 并发标记

  从GC Roots的直接关联独享开始遍历整个对象图的过程

+ 重新标记（STW)

  修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些

+ 并发清除

  清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以可以和用户线程并发执行。


由于cms无法处理浮动垃圾，有可能出现失败，而导致另一次完全STW的full GC 产生

#### G1

收集器是面向局部收集的设计思路和基于Region的内存布局形式。

面向堆内存任何部分来组成回收集（CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC 模式。

G1把连续的java堆划分为多个大小相等的独立区域，每个region都可以根据需要，扮演新生代的Eden空间，Survivor空间，或者老年代空间。收集器能够扮演不同角色的Region采用不同的策略去处理。

G1收集器主要分为4个步骤

+ 初始标记（STW)

  

+ 并发标记

  

+ 最终标记（STW）

  

+ 筛选回收（STW）

  涉及对象的移动，必需暂停用户线程

#### Shenandoah 收集器

openJdk 12中支持，与G1收集器，比较相似，又有三点不同

+ 默认不使用分代收集
+ 摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。

主要的步骤

+ 初始标记

+ 并发标记

+ 最终标记

+ 并发清理

  用于清理那些整个区域内连一个存活对象都没有找到的Region

+ 并发回收

  Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。

+ 初始引用更新（STW）

  并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。

+ 并发引用更新

  真正开始进行运用更新操作

+ 最终引用更新（STW）

  解决了堆中的引用更新后，还需要修正存在于GC Roots中的引用

+ 并发清理

  并发清理过程来回收那些Region的内存空间，供以后新对象分配使用。

#### ZGC

zgc收集器是一款基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。jdk11新加入

染色指针时一种直接将少量额外的信息存储在指针上的技术。

染色指针的三大优势

+ 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。
+ 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。
+ 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

主要的步骤

+ 并发标记

+ 并发预备重分配

  这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集。重分配集与G1收集器的回收集还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描换取省去G1中记忆集的维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他Region中，里面的Region会被释放，而并不能说回收行为就只是指针堆这个集合里面的Region进行，因为标记过程是针对全堆的。

+ 并发重分配

  要把重分配集中的存活对象复制到新的Region中，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的指，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”能力。

+ 并发重映射

  重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用。

### 命令行工具

#### jps 查看进程细腻

```sh
jps -l
```

#### jstat 查看统计信息

```sh
查看pid为1的gc收集信息 1s间隔 输出10次
jstat -gc 1 1000 10

查询pid为1的gc收集信息 1s间隔 输出10次（空间占比）
jstat -gcutil 1000 10
```

#### jinfo 查看配置信息

```sh
jinfo -v 66020

jinfo -flags 66020
```

#### jmap 查看内存

```sh
# 导出 内存文件
jmap -dump:format=b,file=oom.bin 66020
```

#### jhat 虚拟机堆转储快照分析工具

```sh
# 执行后 访问localhost:7000
jhat oom.bin
```

#### jstack 堆栈跟踪工具

```sh
jstack -l 66020
```

### java 字节码结构

#### 魔数

CAFEBABE

次版本号是第5位、第6位

主版本号是第7位、第8位

jdk8是52版本、jdk11是55版本

#### 常量池

常量池主要存放两大类常量：字面量和符号引用，字面量比较接近java语言层面的常量概念，如文本字符串，被声明位final的常量值等。而符号引用则属于编译原理方便的概念，主要包括下面几类常量：

+ 被模块导出或者开放的包
+ 类和接口的全限定名
+ 字段的名称和描述符
+ 方法的名称和描述符
+ 方法句柄和方法类型
+ 动态调用点和动态常量

#### 访问标志

+ acc_public
+ acc_final
+ acc_super
+ acc_interface
+ acc_abstract
+ acc_synthetic
+ acc_annotation
+ acc_enum
+ acc_module

### 字节码

#### 方法调用指令

+ invokevirtual: 用于调用对象的实例方法，根据对象的实际类型进行分配（虚方法分派），这也是java语言中最常见的方法分配方式。
+ invokeinterface: 用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找到适合的方法进行调用
+ invokespecial: 用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
+ invokestatic: 用于调用类静态方法
+ invokedynamic: 用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。

#### 同步指令

虚拟机可以通过方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明位同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。

同步一段指令集序列通常时由java语言中的synchronized语句来表示的，java虚拟机的指令集中有montiorenter和monitorexit两条指令来支持synchronzied关键字的语义。

### 加载机制

#### 类加载的时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期都会经历加载、验证、准备、解析、初始化、使用和卸载7个阶段，其中验证、准备、解析三个部分统称为连接。

以下6种情况必须立即对类进行“初始化”

+ 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，能够生成这四条指令的典型java代码场景有：
  + 使用new关键字实例化对象的时候
  + 读取或设置一个类型的静态字段（被final、已在编译期把结果放入常量池的静态字段除外）的时候
  + 调用一个类型的静态方法的时候。
+ 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化
+ 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
+ 当虚拟机启动时，用户需要指定一个要执行的主类（包含main() 方法的那个类），虚拟机会先初始化这个主类。
+ 当使用jdk7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getstatic、REF_putStatic、REF_invokeStatic、REF_newinvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化
+ 当一个接口汇总定义了jdk8新加入的默认方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

#### 类加载的过程

##### 加载

会完成三件事情

+ 通过一个类的全限定名来获取定义此类的二进制字节流
+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口.

##### 验证

验证字节码时java虚拟机保护自身的一项必要措施。

验证阶段大致上会完成下面四个阶段的检验动作

+ 文件格式的验证
  魔数、主次版本号、常量池的常量是否有不被支持的常量类型 等等等

  主要目的是保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个java类型信息的要求。

+ 元数据验证

  这个类是否有父类、父类是否继承了不允许被继承的类、如果部署抽象类，是否实现了父类或接口中的方法

  主要目的是对类的元数据信息进行语义校验，保证不存在与“java语言规范”定义相悖的元数据信息

+ 字节码验证

  主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体（Class文件中的Code属性）进行校验分析。

+ 符号引用验证

  该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

  符号引用中通过字符串描述的全限定名是否能够找到对应的类，符号引用的类、字段、方法的可访问性是否可被当前类访问等等。
##### 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

内存分配的仅包含类变量，而不包含实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。

##### 解析

将常量池内的符号引用替换为直接引用的过程。

符号引用：符号引用以一组符号来描述所引用的目标，符号可以时任何形式的字面量，只要使用时能无歧义地定位到目标即可。引用的目标并不一定是已经加载到虚拟机内存中的内容。

直接引用：直接引用时可以直接指向目标的指针，相对便宜量或者是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

+ 类或接口的解析

  非数组类型，会根据全限定名给加载器加载，加载过程可能触发其他类的加载，一旦这个过程出现异常则宣告失败

  数组类型，会加载数组元素类型

  还要进行符号引用的验证，确认是否具备访问权限。

+ 字段解析

+ 方法解析

+ 接口方法解析

#### 初始化

在准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。

初始化阶段就是执行类构造器<clinit>() 方法的过程。

<clinit>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。

#### 类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在java虚拟机中的唯一性。

比较两个类是否"相等", 只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个java虚拟机加载，只要加载它们的类加载器不同，那这两个类必定不相等。

##### 双亲委派模型

+ 启动类加载器（bootstrap class loader）：这个类加载器负责加载存放在<JAVA_HOME>/lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是java虚拟机能够识别的类库加载到虚拟机的内存中。

+ 扩展类加载器(Extension class loader)：这个类加载器是在类sun.misc.Launcher$ExtClasLoader中以java代码的形式实现的。负责加载<JAVA_HOME>/lib/ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。

+ 应用程序类加载器(application class loader)：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。有些场合也称为"系统类加载器",负责加载用户类路径(Class path)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

双亲委派模型要求除了顶层的启动类加载器外，其余类的类加载器都应有自己的父类加载器。这个类加载器之间的父子关系一般部署以继承的关系实现的，而是通常使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是java中的类随着它的类加载器一起具备一种带有优先级的层次关系。

##### 破坏双亲委派机制

共3次较大规模的破坏

+ 1.2之前，为了兼容已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在jdk1.2之后的java.lang.Classloader中添加一个新的protected 方法findClass()，并引导用户编写的类加载器尽可能去重写这个方法，而不是在loadClass () 中编写代码。

+ JNDI服务提供这接口SPI的代码。引入了线程上下文类加载器（Thread Context Classloader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置的话，那这个类加载器默认就是应用程序类加载器。JNDI服务使用这个线程上下文类加载器去加载所需要的SPI服务代码，这个一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。

+ 用户对程序动态性的追求导致的，代码热替换、模块热部署等

### 栈帧

栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。
为了节约栈帧的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用于并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出某个变量的作用域，那这个变量对应的变量槽就可以就可以交给其他变量重用。

```java
public static void main(String[] args){
  {
   byte[] placeholder = new byte[64 * 1024 * 1024];
  }
  //这个位置重新赋值，会导致变量槽重用 之后会回收，否则可能不会回收，那么我们手动赋值null是有意义的
  int i = 0;
  System.gc();
}
```

### 操作数栈

### 动态链接

### 方法调用

调用不同类型的方法，字节码指令集里设计了不同的指令，在java虚拟机支持以下5条方法调用字节码指令，

+ invokestatic: 用于调用静态方法
+ invokespecial: 用于调用实例构造器<init>() 方法、私有方法和父类方法
+ Invokevirtual：用于调用所有的虚方法
+ Invokeinterface: 用于调用接口方法，会在运行时再确定一个实现该接口的对象
+ invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在java虚拟机内部，而invokedtnamic指令的分派逻辑是由用户设定的引导方法来决定的。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的 方法共有静态方法、私有方法、实例构造器、父类方法4中，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”,与之想法，其他方法就被称为"虚方法"。

### tomcat 类加载架构

部署在同一个服务器上的两个web应用程序所使用的java类库可以实现相互隔离。

在tomcat目录结构中，可以设置三组目录（`/common/*`、`/server/* `、`/shared/*` ，但默认不一定是开放的，可能只有`/lib/*`目录存在) 用于存放java类库，另外还应该加上web应用程序自身的"WEB-INF/*"目录,一共四组。把java类库放置在这四组目录中，分别是：

+ /common 目录，类库可被tomcat和所有web应用程序共同使用
+ /server 目录，类库可被tomcat使用，对所有的web应用程序都不可见
+ /shared 目录，类库可被所有的web应用程序共同使用，但对tomcat自己不可见
+ /Webapp/WEB-INF目录中，类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序不可见。

为了支持这套目录结构，tomcat自定义了多个类加载器。

![image-20220419072231249](/Users/wangqd/Library/Application Support/typora-user-images/image-20220419072231249.png)

灰色的是jdk默认提供的类加载器

common类加载器、Catalina加载器（也称为Server类加载器）、Shared类加载器和Webapp类加载器则是tomcat自定义的类加载器，他们分别加载/common 、/server、/shared、和/WebApp/WEB-INF 中的java类库。其中webApp类加载器和JSP类加载器通常还会存在多个实例，每个web应用程序对应一个webApp类及载器，每一个jsp文件对应一个jasperLoader类加载器。

### OSGI



### 前端编译优化

新生的java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者java虚拟机的底层改进来支持。

### happen-before

#### 场景

+ 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构
+ 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后
+ volatile变量规则：对一个volatile变量的写操作先行发生于后面这个变量的读操作，这里的“后面”同样是指时间上的先后
+ 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
+ 线程终止规则：线程中所有操作都先于发生于此线程的终止检测，我们可以通过Thread::join方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
+ 线程中断规则：对线程interrrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生
+ 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始
+ 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作于操作C的结论。

java语言无须任何同步手段保障就能成立的happen-before有且只有上面这些。

### 线程

#### 内核线程

内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核额度一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口 -- 轻量级进程，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。

每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先，由于是基于内核线程实现，所有各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对比较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

#### 用户线程

使用用户线程实现的方式被称为1:N实现。广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程的一种，因此从这定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，饼不具备通常意义的用户线程的优点。

#### java 线程的实现

1.3之后，基于操作系统原生线程模型实现，即采用1:1的线程模型。

#### java线程调度

调度方式有两种，分别是协同式线程调度和抢占式线程调度

如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步问题。线程时间不可控，可能一直阻塞。

如果是抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身决定。比如在java中，有Thread::yield() 方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么方法的。

java使用的线程调度方式就是抢占式调度。

#### 状态转换

java语言定义了6种线程状态

+ 新建（New）：创建后尚未启动的线程处于这种状态
+ 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待操作系统为它分配执行时间。
+ 无期限等待（waiting）：处于这种状态的线程不会被分配处理器执行时间，他们要等待被其他线程显示唤醒。以下会让线程陷入无限期的等待状态
  + 没有设置Timeout参数的Object::wait()
  + 没有设置Timeout参数的Thread::join()
  + LockSupport::park()方法
+ 限期等待（timed waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显示唤醒，在一定时间之后他们会由系统自动唤醒。
  + Thread ::sleep方法
  + 设置了timeout参数的Object::wait() 方法
  + 设置了timeout参数的Thread::join() 方法
  + LockSupport::partNanos()方法
  + LockSupport::parkUntil()方法
+ 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；而“等待状态”则在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的同时，线程将进入这种状态。
+ 结束(terminated)：已终止线程的线程状态，线程已经结束执行

![image-20220426080807915](/Users/wangqd/Library/Application Support/typora-user-images/image-20220426080807915.png)

#### 协程

如果不显示设置-Xss或-XX:ThreadStackSize ,则在64位Linux上Hotspot的线程栈容量默认是1MB，此外内核数据结构还会消耗16KB内存。

与之相对的，一个协程的栈通常在几百字节到几KB之间。

### 锁优化

#### 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程再运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

### Lock

lock相对于sychronized相比的好处

+ 等待可中断
+ 公平锁
+ 锁绑定多个条件

#### 锁优化
##### 自旋锁：默认自旋10次，之后传统方式挂起线程
##### 自适应自旋：自旋的时间不再固定。
##### 锁消除：
##### 锁粗化：
##### 轻量级锁：
对象头分为两部分，第一部分是用于存储对象自身的运行时数据，如hashCode、GC分代年龄等，这部分数据的长度在32位和64位的java虚拟机中分别会占用32个或64个比特，官方称为Mark word。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有额外的部分用于存储数组长度。

未被锁定的状态下，mark word的32个比特空间里的25个比特将用于存储对象哈希码，4比特年龄，2比特存储锁标志位，还有1比特固定为0（表示未进入偏向模式）。

![image-20220427075735442](/Users/wangqd/Library/Application Support/typora-user-images/image-20220427075735442.png)

轻量级锁工作过程：

在代码即将进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前的栈帧中建立一个名为锁记录（lock record）的空间，用于存储锁对象目前mark word的拷贝，这时候线程堆栈与对象头的状态

![image-20220427080115277](/Users/wangqd/Library/Application Support/typora-user-images/image-20220427080115277.png)

然后，虚拟机将使用cas操作尝试把对象的mark word更新为指向lock record的指针。如果这个更新动作成功了，即代表线程拥有这个对象的锁，并且对象mark word的锁标志位（mark word的最后两个比特）将转变为00，表示此对象处于轻量级锁状态。这时候线程堆栈与对象头的状态

![image-20220427080327248](/Users/wangqd/Library/Application Support/typora-user-images/image-20220427080327248.png)

如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取对象的锁，虚拟机首先会检查对象的mark word 是否指向当前线程的栈帧，如果是，说明当前线程已拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值为10，此时mark word中存储的就是指向重量级锁（互斥）的指针，后面等待锁的线程也必须进入阻塞状态。

##### 偏向锁

偏向锁就是在无竞争的情况下把整个同步都消除掉，连cas操作都不去做了

工作过程：

假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头的标志设置为01、把偏向模式设置为1，表示进入偏向模式。同时使用cas操作把获取到这个锁的线程id记录在对象的mark word之中。如果cas操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

一旦出现另一个线程尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为0），撤销后标志位恢复到未锁定（标志位位01）或轻量级锁定（标志位为00）的状态，后续的同步操作就按照上面的轻量级锁那样去执行。

![image-20220427081541338](/Users/wangqd/Library/Application Support/typora-user-images/image-20220427081541338.png)













































